# 二、K8s 的证书

## 有关 K8s 的证书

K8s 各个组件的交互都是走的 HTTPS：controller 访问 apiserver 走 https，kubelet 访问 apiserver 走 https，甚至我们使用的 kubectl 工具做各种操作的时候也是用的 https 访问了 apiserver。

这和我们用浏览器访问网站时候用到的 HTTPS 比较类似。不过，K8s 使用的是双向认证，也就是说，不光服务端要准备证书和 Key，客户端为了证明自己的身份，也要准备自己的证书和 Key。

为了简化，我们下面只准备几个证书，各个组件里面能共用的就共用。

| 证书                 | 用到这个证书的组件 | 文件                                                  | 角色                                 |
| :------------------- | ------------------ | ----------------------------------------------------- | ------------------------------------ |
| CA                   | 所有               | <ul><li>ca.key</li><li>ca.crt</li></ul>               | 根证书                               |
| API Server 证书      | kube-apiserver     | <ul><li>apiserver.crt</li><li>apiserver.key</li></ul> | API Server 的服务端证书              |
| Client 证书          | 各种组件都会用     | <ul><li>client.crt</li><li>client.key</li></ul>       | 用来表明自己身份的证书               |
| Service Account 证书 | kube-apiserver     | <ul><li>sa.pub</li><li>sa.key</li></ul>               | Service Account JWT Token 的签发证书 |

> [!NOTE]  
> Service Account 证书是一对公私钥，和前面说到的 HTTPS 双向认证证书说的不是一个东西。这个后面会再提到。

## 生成 CA 证书

证书是一个树状的结构，CA 是这个树状结构的根，K8s 其他证书的生成过程中都要带上 CA 的证书，仿佛是声明了一种父子关系：其他证书都是这张根证书的“儿子”，他们有一个共同的“父亲”。

生成 CA 这个“父亲”，首先生成一个 Key：

```sh
cd /etc/kubernetes/pki/
openssl genrsa -out ca.key 4096
```

然后生成证书

```sh
openssl req -x509 -new -nodes -key ca.key -subj "/CN=kubernetes-ca" -days 3650 -out ca.crt
```

这样我们就有了 CA 这个“父亲“的 `.key` 和 `.crt` 文件

> [!NOTE]
> 生成证书的过程一般分成 3 步骤：生成私钥（.key），然后生成“证书生成的说明”（.csr），最后拿着 Key 和 CSR 生成证书（.crt）。
>
> 在创建 CA 证书的时候，我们跳过了中间 CSR 的步骤，因为 CA 证书不用填太多信息，所以可以省略。

## 生成 API Server 的证书

接下要生成的是 API Server 的证书，这个证书很像平时我们所谓的 HTTPS 证书，主要放在了服务端，用来证明自己确实是 API Server。

首先生成 API Server 的 Key

```sh
openssl genrsa -out apiserver.key 4096
```

接下来，到这里我们需要生成 API Server 证书的 CSR。

这里有一个事情要注意。我们有很多客户端，他们访问 API Server 的时候使用的地址并不相同：有些是通过 Service IP（10.96.0.1）访问过来的，kubelet 有可能访问了 https://master:6443，还有可能是通过 IP 访问过来的，我们的证书要满足这些不同的访问 host。所以，要在签发证书的时候把这些信息都带上，就好像要给 API Server 发一张身份证，上面写了 API Server 的不同的名字，这些名字都合法。

在证书技术里，指定多个地址的技术叫作 Subject Alternative Names (SANs)，下面我们把 SAN 信息加入到 CSR 里。

复制下面的内容到 `apiserver.csr.conf`

```ini
[ req ]
default_bits       = 4096
prompt             = no
default_md         = sha256
distinguished_name = req_distinguished_name
req_extensions     = v3_req

[ req_distinguished_name ]
C  = US
ST = California
L  = San Francisco
O  = MyCompany
OU = IT
CN = kube-apiserver

[ v3_req ]
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kube-apiserver
DNS.2 = kubernetes
DNS.3 = kubernetes.default
DNS.4 = kubernetes.default.svc
DNS.5 = kubernetes.default.svc.cluster.local
DNS.6 = master                      # Hostname
IP.1  = 10.96.0.1                   # Service IP，看情况改
IP.2  = 192.168.56.10               # Master 的 IP，看情况改
```

然后用这个配置文件生成 CSR

```sh
openssl req -new -key apiserver.key -out apiserver.csr -config apiserver.csr.conf
```

最后，用 apiserver.csr、还有 CA 的 .key 和 .csr 生成 apiserver.crt（前面一步的 .key 已经包括到 .csr 里面了，所以不用指定 .key）

```sh
openssl x509 -req -in apiserver.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out apiserver.crt -days 3650
```

这样就得到了 `apiserver.key` 和 `apiserver.crt`。

## 生成 Client 证书

接下来我们要生成一张 Client 证书，给各个访问 API Server 的组件使用。

> [!WARNING]
> 我们这次安装的 K8s 全靠证书来证明身份。我们接下来创建的证书是给超管用的，有了它就能证明自己是 K8s “超级管理员”。这个证书也会配置给 controller，scheduler 和 kubelet 的 kubeconfig，并且用这个 config 来访问 API Server，但其实这些组件各自有各自的身份，按理来说应该给它们分别创建证书，我们这里为了简化所以只用一张证书。
>
> 不要在正式环境这样做。

首先创建 `client.key`。

```sh
openssl genrsa -out client.key 4096
```

然后生成一个 `client.csr`。

```sh
openssl req -new -key client.key -subj "/CN=admin/O=system:masters" -out client.csr
```

最后用这个 `client.csr`，还有 `ca.key` 和 `ca.crt` 生成 `client.crt`。

```sh
openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt -days 3650
```

这样就获得了 `client.crt` 和 `client.key`。

> [!NOTE]
> 生成 CSR 的时候，我们指定了 `CN=admin,O=system:masters`。这句话对应着 K8s 里面一个预设的配置：凡是在 `system:masters` 组的用户，都是超管。
> 我们这里写了这个`CN=admin,O=system:masters`就像是在说，这个用户叫 `admin`，他属于 `system:masters` 这个组，写上这句，K8s 就认他是超管。
> 我们生成 client.csr 的时候没有用到 .conf 文件，是因为这个 .csr 的配置信息比较简单，用命令生成更方便一些。

## 生成 Service Account 公私钥

和前面的证书 / Key 不同，Service Account 证书是一对公私钥。

有时候 Pod 也要和 Kubernetes 的 API 交互，因此在 Pod 创建的时候，Kubernetes 会为每个 Pod 创建一个 JWT Token 做为交互凭证，这个 Service Account 的公私钥就是用来生成和验证 JWT Token 的。

生成私钥 `sa.key`

```bash
openssl genrsa -out sa.key 4096
```

生成公钥 `sa.pub`

```bash
openssl rsa -in sa.key -pubout -out sa.pub
```

接下来开始[安装 Master 节点](/cn/03-安装Master节点.md)。
