# 二、K8s 的证书

K8s 各个组件的交互都是走的 HTTPS：controller 访问 apiserver 走 https，kubelet 访问 apiserver 走 https，甚至我们使用的 kubectl 工具做各种操作的时候也是用的 https 访问了 apiserver。

这和我们用浏览器访问网站时候用到的 HTTPS 比较类似。不过，K8s 使用的是双向认证，也就是说，不光服务端要准备证书和 Key，客户端为了证明自己的身份，也要准备自己的证书和 Key。

为了简化，我们下面只准备几个证书，各个组件里面能共用的就共用。

| 证书                 | 用到这个证书的组件 | 文件                                                   | 角色                                 |
| :------------------- | ------------------ | ------------------------------------------------------ | ------------------------------------ |
| CA                   | 所有               | <ul><li>ca-key.pem(KEY)</li><li>ca.pem(证书)</li></ul> | 根证书                               |
| API Server 证书      | kube-apiserver     | <ul><li>apiserver.crt</li><li>apiserver.key</li></ul>  | API Server 的服务端证书              |
| Client 证书          | 各种组件都会用     | <ul><li>client.crt</li><li>client.key</li></ul>        | 用来表明自己身份的证书               |
| Service Account 证书 | kube-apiserver     | <ul><li>sa.pub</li><li>sa.key</li></ul>                | Service Account JWT Token 的签发证书 |

> [!NOTE]  
> Service Account 证书是一对公私钥，和前面说到的 HTTPS 双向认证证书说的不是一个东西。这个后面会再提到。

## 工具准备

这个部分我们用 Cloudflare 的 SSL 工具 `cfssl`。

下载地址在这里：[https://github.com/cloudflare/cfssl/releases/](https://github.com/cloudflare/cfssl/releases/)

我们主要用到里面的 `cfssl` 和 `cfssljson` 这两个二进制。

```bash
wget https://github.com/cloudflare/cfssl/releases/download/v1.6.5/cfssl_1.6.5_linux_amd64
wget https://github.com/cloudflare/cfssl/releases/download/v1.6.5/cfssljson_1.6.5_linux_amd64

mv cfssl_1.6.5_linux_amd64 /usr/local/bin/cfssl
mv cfssljson_1.6.5_linux_amd64 /usr/local/bin/cfssljson

chmod +x /usr/local/bin/cfssl
chmod +x /usr/local/bin/cfssljson
```

我们趁这个机会把 `/usr/local/bin` 放在 `PATH` 里，后面其他的 bin 也都会放在这里。

```bash
echo "export PATH=$PATH:/usr/local/bin" >> ~/.bash_profile
source ~/.bash_profile
```

你可能听说 OpenSSL 也能生成证书的工具。那个用起来有一些难受，所以我们在创建证书的时候就不用那个了，创建 Key 的时候会简单用用。

## 生成 CA 证书

证书是一个树状的结构，CA 证书是这个树状结构的根，K8s 其他证书的生成过程中都要带上 CA 的证书，仿佛是声明了一种父子关系：其他证书都是这张根证书的“儿子”，他们有一个共同的“父亲”。

我们先来生成 CA 这个“父亲”。

```bash
cd /etc/kubernetes/pki/
```

创建 `ca-csr.json` 文件，写下面的内容。

```json
{
  "CN": "IKFB",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "San Francisco",
      "O": "Kubernetes",
      "OU": "CA",
      "ST": "California"
    }
  ]
}
```

然后用 `cfssl` 工具生成 `ca-key.pem` 密钥和 `ca.pem` 证书。

```sh
cfssl genkey -initca ca-csr.json | cfssljson -bare ca
```

## 生成 API Server 的证书

接下要生成的是 API Server 的证书，这个证书很像平时我们所谓的 HTTPS 证书，主要放在了服务端，用来证明自己确实是 API Server。

这里有一个事情：我们有很多客户端，他们访问 API Server 的时候使用的地址并不相同：有些是通过 Service IP（10.96.0.1）访问过来的，有可能访问了 https://master:6443，还有可能是通过 IP 访问过来的（192.168.56.10），我们的证书要满足这些不同的访问 host。所以，要在签发证书的时候把这些信息都带上，就好像要给 API Server 发一张身份证，上面写了 API Server 的不同的名字，这些名字都合法。

在证书技术里，指定多个地址的技术叫作 Subject Alternative Names (SANs)，一会儿我们会把 SAN 信息也放在创建证书的描述文件里。

复制下面的内容到 `apiserver-csr.json`。

```json
{
  "CN": "kube-apiserver",
  "hosts": [
    "kubernetes",
    "kubernetes.default",
    "kubernetes.default.svc",
    "kubernetes.default.svc.cluster.local",
    "master",
    "10.96.0.1",
    "192.168.56.10"
  ],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "US",
      "L": "San Francisco",
      "O": "Kubernetes",
      "OU": "Kubernetes"
    }
  ]
}
```

然后我们生成 API Server 的证书和 Key。

```bash
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -profile=kube-apiserver kube-apiserver-csr.json | cfssljson -bare kube-apiserver
```

这样就得到了 `kube-apiserver-key.pem` 和 `kube-apiserver.pem`。

## 生成 Client 证书

接下来我们要生成一张 Client 证书，给各个访问 API Server 的组件使用。

我们这次安装的 K8s 全靠证书来证明身份。我们接下来创建的证书是给超管用的，有了它就能证明自己是 K8s “超级管理员”。

这个证书也会配置给 controller，scheduler 和 kubelet 的 kubeconfig，并且用这个 config 来访问 API Server。

但其实这些组件各自有各自的身份，按理来说应该给它们分别创建证书和 Kubeconfig，我们这里为了简化，所以只用一张证书。

不要在正式环境这样做。

首先创建 `client-csr.json`。

```json
{
  "CN": "admin",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "O": "system:masters"
    }
  ]
}
```

然后执行创建证书的命令。

```sh
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem client-csr.json | cfssljson -bare client
```

这样就获得了 `client-key.pem` 和 `client.pem`。

命令执行完，可能你会看到了一条提示“[WARNING] This certificate lacks a "hosts" field...”，这句话是说，因为我们我们没写 hosts，所以这个证书不适合拿去给服务器来标记身份。我们本身也不拿这个证书当服务端证书用，所以可以忽略。

我们指定了 `CN=admin,O=system:masters`。这句话对应着 K8s 里面一个预设的配置：凡是在 `system:masters` 组的用户，都是超管。

我们这里写了这个`CN=admin,O=system:masters`就像是在说，这个用户叫 `admin`，他属于 `system:masters` 这个组，写上这句，K8s 就认他是超管。

## 生成 Service Account 公私钥

和前面的证书 / Key 不同，Service Account 证书是一对公私钥。

有时候 Pod 也要和 Kubernetes 的 API 交互，因此在 Pod 创建的时候，Kubernetes 会为每个 Pod 创建一个 JWT Token 做为交互凭证，这个 Service Account 的公私钥就是用来生成和验证 JWT Token 的。

这个比较简单，我们直接用 OpenSSL 生成。

生成私钥和公钥

```bash
# 生成私钥
openssl genrsa -out sa-key.pem 2048
# 用私钥生成公钥
openssl rsa -in sa-key.pem -pubout -out sa-pub.pem
```

接下来开始[安装 Master 节点](/cn/03-安装Master节点.md)。
